<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Linker Algorithm Planning</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({ startOnLoad: true });</script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
        }

        code {
            background: #f4f4f4;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }

        .mermaid {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            text-align: center;
        }

        .note {
            background: #e8f4f8;
            padding: 15px;
            border-left: 5px solid #3498db;
            margin: 20px 0;
        }
    </style>
</head>

<body>

    <h1>Smart Linker Algorithm Planning</h1>

    <div class="note">
        <strong>Goal:</strong> Robustly link real-time API data (SIRI/Timetables) with static schedule data (GTFS/NeTEx)
        to provide rich context (platforms, accessibility) for every journey.
    </div>

    <h2>1. The Challenge</h2>
    <p>The DB Timetables API provides live data (e.g., "ICE 690", "+5 min delay"), but it lacks static details like
        accessibility info or full stop lists. GTFS contains this static data but uses internal IDs (`trip_id`). We need
        a reliable way to map <code>API Train -> GTFS Trip</code>.</p>

    <h2>2. Proposed Algorithm: "Smart Linker"</h2>
    <p>Inspired by industry standards (like HAFAS Reconstruction), we propose a multi-level matching strategy.</p>

    <div class="mermaid">
        flowchart TD
        Start[Input: API Train Data] --> L1{Level 1: Strict Match}

        L1 -->|Success| Found[Link Found: GTFS Trip ID]
        L1 -->|Fail| L2{Level 2: Fuzzy Match}

        L2 -->|Success| Validate{Level 3: Spatial Validation}
        L2 -->|Fail| AI{Level 4: AI Resolution}

        Validate -->|Valid| Found
        Validate -->|Invalid| AI

        AI -->|Resolved| Found
        AI -->|Unresolved| Fallback[Return Live Data Only]
    </div>

    <h3>Level 1: Strict Match (The "Happy Path")</h3>
    <p>We attempt to find an exact match based on high-confidence identifiers.</p>
    <ul>
        <li><strong>Criteria:</strong>
            <ul>
                <li><code>Train Number</code> matches exactly (e.g., "690").</li>
                <li><code>Category</code> matches exactly (e.g., "ICE").</li>
                <li><code>Departure Time</code> matches within <strong>±5 minutes</strong>.</li>
                <li><code>Origin/Destination</code> matches (if available).</li>
            </ul>
        </li>
    </ul>

    <h3>Level 2: Fuzzy Match (The "Resilient Path")</h3>
    <p>If strict matching fails (e.g., due to data inconsistencies or significant delays), we relax the constraints.</p>
    <ul>
        <li><strong>Criteria:</strong>
            <ul>
                <li><code>Train Number</code> matches exactly.</li>
                <li><code>Category</code> is ignored (handles "ICE" vs "IC" labeling issues).</li>
                <li><code>Departure Time</code> matches within <strong>±60 minutes</strong> (handles major delays).</li>
            </ul>
        </li>
    </ul>

    <h3>Level 3: Spatial Validation (The "Sanity Check")</h3>
    <p>To prevent false positives from Fuzzy Matching (e.g., two trains with number "690" on different days/lines), we
        validate against the station board.</p>
    <ul>
        <li><strong>Check:</strong> Does the candidate GTFS trip actually stop at the current station (`stop_id`)?</li>
    </ul>

    <h3>Level 4: AI Resolution (The "Agentic Edge")</h3>
    <p>If algorithmic matching fails, we leverage the LLM to resolve ambiguities.</p>
    <ul>
        <li><strong>Scenario:</strong> "Frankfurt" is ambiguous (Main vs. Oder).</li>
        <li><strong>Action:</strong> Agent analyzes the context and suggests the correct station EVA/ID to retry the
            match.</li>
    </ul>

    <h2>3. Data Structure Updates</h2>
    <p>To support this, we need to optimize our SQLite schema for fast lookups.</p>

    <div class="mermaid">
        erDiagram
        TRIPS ||--o{ STOP_TIMES : contains
        TRIPS {
        string trip_id PK
        string trip_short_name "Train Number (690)"
        string route_id
        }
        ROUTES {
        string route_id PK
        string route_short_name "Category (ICE)"
        }
        STOP_TIMES {
        string trip_id FK
        string stop_id FK
        string departure_time
        }
    </div>

</body>

</html>